#include <iostream>
#include <fstream>
#include <vector>
#include <exception>
#include <cmath>
#include <algorithm>

/*
    NOTE:   I am making the assumption of each block containing 1000 ticks of data. The specification
            states that the logged data does not contain the channel identifier. This means the only 
            way we can know which data belongs to which channel, is by either knowing the boundaries
            of the ticks, or having a pre-determined number of ticks per block.
*/
static constexpr unsigned int BLOCK_SIZE = 1000;

class Channel {
    public:
        unsigned int uid;               // Channel identifier, unique number, could be pseudorandomly generated
        unsigned int frequencyHz;       // Frequency in hertz that this channel generates data
        unsigned int data;              // The data this channel generates
        /*
            @uid - Unique identifier of this channel
            @frequencyHz - The frequency at which this channel generates data
            @data - The data generated by this channel, in the real world this would of course not be
                    fixed in value...
        */
        Channel(unsigned int uid, unsigned int frequencyHz, unsigned int data) : uid(uid), frequencyHz(frequencyHz), data(data) {}
        /*
            Returns the tick number multiple on which this channel will generate data. For example if 
            the frequency of this channel is 10, 1000 / 10 = 100. Thus this channel would generate
            data every 100th tick
        */
        inline unsigned int GetTick() {
            return BLOCK_SIZE / this->frequencyHz;
        }
        /*
            Overload the < operator so we can apply the std library sort() algorithm
        */
       inline bool operator < (const Channel& other_channel) {
           // Another Channel object is considered less than if its UID is higher than ours, and its 
           // frequency is lower than ours, this is because the interleaved data is stored in descending 
           // frequency, and ascending channel identifier, per tick
           return (uid < other_channel.uid && frequencyHz > other_channel.frequencyHz);
       }
};

/*
    Cosworth interleaved data format
    * Block start time in miliseconds.
    * Length of data in the block.
    * Data with one or more ticks. Each tick contains a set of channel data values.
            * Descending in frequency
            * Ascending channel identifier
*/
struct InterleavedData {
    unsigned int blockStartTimeMs;
    unsigned int lengthOfBlockBytes;
    std::vector<unsigned int> data;
};

/*
    Cosworth continuous data format
    * Channel identifier, this corresponds to the UID of the channel that generated the data
    * Start time identifies the first tick that data was seen from this channel
    * Frequency identifies the rate at which data is generated by this channel
    * Sample count is how many pieces of data this channel has generated == data.size()
    * Data is the actual data we have retrieved from the interleaved format
*/
struct ContinuousData {
    unsigned int channelIdentifier;
    unsigned int startTimeMs;
    unsigned int frequencyHz;
    unsigned int sampleCount;
    std::vector<unsigned int> data;
};

/*
    Create channel information, needed for the generation of interleaved data, and the conversion
    from interleaved to continuous
    
    Returns the channel information needed to generate both interleaved and continuous data
*/
std::vector<Channel> generate_channels() {
    std::vector<Channel> channels;

    try {
        // Our test channels, generating data at rates of 5, 100 and 200Hz
        Channel channel_0(0, 5, 0);
        Channel channel_1(1, 100, 1);
        Channel channel_2(2, 200, 2);

        // Store all of our channels into one easy to access vector.
        channels = {channel_0, channel_1, channel_2};

        // Sort our vector according to the Cosworth format. This uses the overloaded < operator
        // in our Channel class defined above
        std::sort(channels.begin(), channels.end());
    } catch (std::exception& e) {
        std::cerr << e.what() << std::endl;
    }

    return channels;
}

/*
    Create interleaved data from a bunch of channels. This is just to provide test data to our 
    generate_continuous_data function
    
    @channels - A vector containing all of the channel information we need to crate interleaved data

    Returns the interleaved channel data
*/
InterleavedData generate_interleaved_data(std::vector<Channel>& channels) {
    // Zeroize our structure
    InterleavedData interleaved_data = {0};

    try {
        interleaved_data.blockStartTimeMs = 0;

        /* 
        Generate the test channel data, by the end of this loop, we will only end up with the amount 
        of data the channels would generate. For example if we have channels on 5, 100 and 200Hz, we
        will end up with a block of data containing 305 values
        */
        for (int tick = 0; tick < BLOCK_SIZE; tick++) {
            for (auto& channel : channels) {
                // If the current tick is a tick that this channel would generate data on, then add the data
                if (tick % channel.GetTick() == 0) {
                    interleaved_data.data.push_back(channel.data);
                }
            }
        }

        // Set the number of bytes contained in our interleaved data
        interleaved_data.lengthOfBlockBytes = interleaved_data.data.size() * sizeof(unsigned int);

        // Interleaved data input file
        std::ofstream interleaved_data_file;
        interleaved_data_file.open("C:\\Users\\JB\\Desktop\\Cosworth assessment\\output\\cosworth_interleaved_block_data.txt", std::ios::out);

        // Print to file the interleaved data we are using as input
        if (interleaved_data_file.is_open()) {
            interleaved_data_file << "Block start time (ms): " << interleaved_data.blockStartTimeMs << "\nData length (bytes): "
            << interleaved_data.lengthOfBlockBytes << std::endl;
            for (auto& value : interleaved_data.data) {
                interleaved_data_file << value << std::endl;

            }
            interleaved_data_file.flush();
            interleaved_data_file.close();
        }
    } catch (std::exception& e) {
        std::cerr << e.what() << std::endl;
    }

    return interleaved_data;
}

/*
    This is the function we have been tasked with writing, to convert from interleaved format, into
    a continuous data format for each sensor

    NOTE:   Because the data when generated was created with the sensors in the specified order, we
            only need to make sure we read the interleaved data with the same channel information
            in the same order. This works because we can put anything inside a container in a certain
            order, and as long as we take things out of that container in the same order (because we
            are taking things out from the front, not the back...), we will have the items we expect 
            at each step. Unless certain items have been ommited due to logging errors etc... I 
            elaborate on what I mean by this in part_two.txt

    @channels - A vector containing all of the channel information contained within the interleaved data,
                notably we only make use of the frequency and uid, as suggested in the spec
    @interleaved - The interleaved data we are converting

    Returns the interleaved data restructed into the Cosworth continuous data format
*/
std::vector<ContinuousData> generate_continuous_data(std::vector<Channel> channels, InterleavedData interleaved) {
    std::vector<ContinuousData> continuous_data;

    try{
        // Iterate over all of the channels, and create a new structure defining the continuous data, and push
        // it to the back of a vector where we store our continuous_data
        for (auto& channel : channels) {
            ContinuousData cd = {0};
            cd.channelIdentifier = channel.uid;
            cd.frequencyHz = channel.frequencyHz;
            continuous_data.push_back(cd);
        }

        // Iterate over an entire blocks worth of ticks. If the current tick we are on is one that a channel would have
        // generated data on, then we know that the current bit in our interleaved data is one generated by said channel
        for (int tick = 0; tick < BLOCK_SIZE; tick++) {
            // Iterate over all of the generated channels for each tick
            for (unsigned int current_channel = 0; current_channel < channels.size(); current_channel++) {
                // If the current tick is a tick that the current channel would generate data on, then get the data
                if (tick % channels.at(current_channel).GetTick() == 0) {
                    // Add to the continuous data the current interleaved data at index 0
                    continuous_data.at(current_channel).data.push_back(interleaved.data.at(0));
                    // Increment our sample count for the current channel since we have found new data
                    continuous_data.at(current_channel).sampleCount += 1;

                    // If we are yet to assign a start time to the current channels data, then do so now as the interleaved data
                    // start time plus the current tick we are on
                    if (continuous_data.at(current_channel).startTimeMs == 0) {
                        continuous_data.at(current_channel).startTimeMs = interleaved.blockStartTimeMs + tick;
                    }

                    // Remove the piece of interleaved data at index 0, aka the piece of data we have just digested
                    interleaved.data.erase(interleaved.data.begin());
                }
            }
        }

        // Continuous data output file
        std::ofstream continuous_data_file;
        continuous_data_file.open("C:\\Users\\JB\\Desktop\\Cosworth assessment\\output\\cosworth_continuous_block_data.txt", std::ios::out);

        // Print our continuous_data
        if (continuous_data_file.is_open()) {
            for (auto& result : continuous_data) {
                continuous_data_file << "Channel UID: " << result.channelIdentifier << "    Start time (ms): " << result.startTimeMs << "    Frequency (Hz): " 
                << result.frequencyHz << "    Sample count: " << result.sampleCount << "    Data: ";
                for (auto& value : result.data) {
                    continuous_data_file << value << ",";
                }
                continuous_data_file << std::endl;
            }
            continuous_data_file.flush();
            continuous_data_file.close();
        }
    } catch (const std::exception& e) {
        std::cerr << e.what() << std::endl;
    }

    return continuous_data;
}

/*
    This function needs no explanation! The starting point of our code...

    Returns -1 on failure, 0 on success
*/
int main(int argc, char* argv[]) {
    std::cout << "Cosworth assessment" << std::endl;

    // Create a vector of Channel objects, that will be used to generate interleaved data
    std::vector<Channel> channels = generate_channels();

    if (channels.size() > 0) {
        // Create interleaved data, according to the Cosworth specification
        InterleavedData interleaved_data = generate_interleaved_data(channels);

        if (interleaved_data.data.size() > 0) {
            // Run our devised algorithm to convert our interleaved data into continuous blocks
            std::vector<ContinuousData> continuous_data = generate_continuous_data(channels, interleaved_data);
        } else {
            std::cerr << "The interleaved data is empty. Exiting..." << std::endl;
            return -1;
        }
    } else {
        std::cerr << "We have no channel data. Exiting..." << std::endl;
        return -1;
    }
    return 0;
}